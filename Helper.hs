--------------------------------------------------------
-- Helper declarations & functions
--------------------------------------------------------
-- This document contains data and type declarations and
-- functions that are needed to parse the VDHL to 
-- Datastruct. It does not have the purpose to parse any
-- of the VHDL, only to aid the parser during this 
-- process.
--
--------------------------------------------------------
{-# LANGUAGE TemplateHaskell #-}
module Helper where

-- Standard Imports
import Datastruct
import Data.Maybe (isNothing)
import qualified Control.Monad.Trans.State as State
import qualified Data.Accessor.Monad.Trans.State as MonadState
import qualified Data.Accessor.Template
import qualified Data.Set as Set

-- VHDL Imports
import Language.VHDL.AST hiding (Function)

-- | A list that contains the entries of the type table. The two tuple entries
-- | are a VHDL id that corresponds with the port it refers to.
type Types = [(VHDLId, PortId -> Port)]


--------------------------------------------------------
-- Environment State
--------------------------------------------------------

-- | The Environment State is a global State in which global variables
-- | are declared. Due to the monadic approach of the environment these
-- | variables are easy accessible in the parser. 
-- | counter    = counts the unique id's that are used in the parser
-- | vhdlFiles  = list of names and corresponding designfiles generated by Clash
-- | types      = typestable
data EnvState = ES {
   counter_   :: Int,                       
   vhdlFiles_ :: [(VHDLId, DesignFile)],
   types_     :: Types
}

-- Let template-haskell derive easy accessors for the state
Data.Accessor.Template.deriveAccessors ''EnvState

-- Make a type alias for computations that work with the state made above
type EnvSession a = State.State EnvState a

-- A pure computation that executes a statefull computation given an initial state
runSession :: EnvSession a -> EnvState -> (a, EnvState)
runSession session initState = State.runState session initState

-- | Adds one to the counter and return the new Id as an String
getNewId ::  EnvSession String
getNewId = do
  curCounter <- MonadState.get counter
  let newId = curCounter + 1
  MonadState.set counter newId
  let stringId = show newId
  return stringId

-- Initition of an empty State, counter starts on 0.
initState = ES 0 [] []

--------------------------------------------------------
-- Backtracking
--------------------------------------------------------

-- | The Backtrack is returned from the deepest level of architecture,
-- | to the top entity. In each level the current ArchElems and Wires 
-- | are added to the fields of the record. 
-- | archElem       = current Architecture element
-- | wires          = list of wires of the current depth
-- | prevArchElems  = list of the previous ArchElems from the current depth
-- |                  and the lower depths
data Backtrack =
  Backtrack {
    archElem      :: ArchElem (),
    wires         :: [Wire ()],
    prevArchElems :: [ArchElem ()]
  } deriving (Eq, Show)

-- | In order to prevent infinite loops some of the Backtrack records
-- | are encapsuled in a Backtrack2 record.
data Backtrack2 =
  Backtrack2 {
    bt   :: Backtrack,
    seen :: Bool
  } deriving (Eq, Show)

-- | List of Architeture elements and Backtrack2 records. In order to detect
-- | infinite loops this lookupTable is constructured during parsing.
type LookupTable2 = [(ArchElem (), Backtrack2)]


--------------------------------------------------------
-- Helper Functions
--------------------------------------------------------

-- Get the outport of an Architecture element
outportOf :: ArchElem a -> Port
outportOf (Function _ _ _ p _ _)  = p
outportOf (Operator _ _ _ p _)    = p
outportOf (Literal _ _ p _)       = p
outportOf (Mux _ _ p _ _)         = p
outportOf (Register _ _ p _)      = p
outportOf (PortReference p)       = p

-- Get the inports of an Architecture element
inportsOf :: ArchElem a -> [Port]
inportsOf (Mux _ inportNames _ _ _)       = inportNames
inportsOf (Operator _ _ inportNames _ _)  = inportNames

-- Get the toplevel id of a Port.
getHighest ::Port -> PortId
getHighest (SinglePort x)   =x
getHighest (MultiPort x _)  =x

-- Catch error for lookup function
sureLookup :: String -> [(String,Port)] -> Port
sureLookup t table
  | isNothing found = error $ "Could not find this:" ++ show t
  | otherwise = x
    where
    found = lookup t table
    Just x = found

-- Adds a name to a Single and MultiPort
portLike :: String -> Port -> Port
portLike name (SinglePort id)   =SinglePort (name ++ (fromdot id))
portLike name (MultiPort id ps) =MultiPort (name ++ (fromdot id)) (map (portLike name) ps)

-- Return the part of an id after the first dot in the name
-- For example: 'name.A.B' returns '.A.B'
fromdot :: String -> String
fromdot []=[]
fromdot (s@(('.'):sx))=s
fromdot (x:xs)=fromdot xs

-- Return the part of an id until the first dot in the name
-- For example: 'name.A.B' returns 'name'
untillDot :: String -> String
untillDot []        =[]
untillDot (('.'):sx)=[]
untillDot (x:xs)    =x: (untillDot xs)